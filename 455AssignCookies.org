* 455 Assign Cookies
** 题目
   Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
*** Note:
    You may assume the greed factor is always positive.
    
    You cannot assign more than one cookie to one child.
*** Example 1:
    #+begin_example
    Input: [1,2,3], [1,1]

    Output: 1

    Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
    And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
    You need to output 1.
    #+end_example
*** Example 2:
    #+begin_example
    Input: [1,2], [1,2,3]

    Output: 2

    Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
    You have 3 cookies and their sizes are big enough to gratify all of the children, 
    You need to output 2.
    #+end_example
** 思路
   先对两个数组按从大到小进行排序，判断饼干是否能让小孩开心，可以就记录一个，数组往后移动。如果不能则跳过这个孩子，对下一个进行比较。
** Java
   #+begin_src java
   class Solution {
       public int findContentChildren(int[] g, int[] s) {
           int gi = 0;
           int si = 0;
           int result = 0;
           Arrays.sort(g);
           Arrays.sort(s);
           while(gi < g.length && si < s.length) {
               if (s[si] >= g[gi]) {
                   result++;
                   gi++;
                   si++;
               }else {
                   si++;
               }
           }
           return result;
       }
   }
   #+end_src
** CPP
   #+begin_src cpp
   class Solution {
   public:
       int findContentChildren(vector<int>& g, vector<int>& s) {
           sort(g.begin(), g.end());
           sort(s.begin(), s.end());
        
           int result = 0;
           int gi = 0;
           int si = 0;
           while (si < s.size() && gi < g.size()) {
               if (s[si] >= g[gi]) {
                   si++;
                   gi++;
                   result++;
               }else {
                   si++;
               }
           }
           return result;
       }
   };
   #+end_src

